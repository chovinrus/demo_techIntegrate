1.sql书写顺序和执行顺序
书写顺序：SELECT -> FROM -> JOIN -> ON -> WHERE -> GROUP BY -> HAVING -> UNION -> ORDER BY ->LIMIT
执行顺序：FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> UNION -> ORDER BY ->LIMIT

2.group_concat函数，将分组查询结果的某列按值组合起来
select id,group_concat(name) from aa group by id;
+------+--------------------+
| id| group_concat(name) |
+------+--------------------+
|1 | 10,20,20|
|2 | 20 |
|3 | 200,500|
+------+--------------------+

3.开窗函数，和聚合函数类似都是对查询结果再进行计算，但是开窗函数不需要group by
# 19、按各科成绩进行排序，并显示排名
select c_id,
       s_id,
       s_score,
       rank() over (partition by c_id order by s_score desc) 排名
from score sc
order by c_id, s_score desc;

4.分页查询
limit offset, size
offset是跳过头几条记录

5.sql template
insert into t
set 

update t
set 
where

delete
from t
where 

select
from t
where 

6.char与varchar
char类型的分配空间是固定的,未达到长度大小,使用空格填补;varchar会自动调整使用必要的空间大小.

7.6大约束
主键约束
外键约束
唯一约束
非空约束
默认约束
检查约束(不生效)

8.事务的ACID特性
原子性A 事务不可再分,要么全部执行要么都不执行
一致性C 事务执行前后始终保持一致性状态,一致性状态是指符合业务逻辑
隔离性I 事务一个事务的执行不能被其他事务干扰
持久性D 事务一旦提交,对数据库的数据改变是永久的

9.并发错误与事务隔离级别
脏读--读到回滚前的数据
不可重复度--读到提交前的数据
幻读--读的过程中有其他事务在执行插入操作
读未提交 并发错误都有
读已提交 可以避免脏读不能避免不可重复度和幻读
可重读 可以避免脏读不可重复读,不能避免幻读
可串行化 可避免三种并发问题

10.视图--虚拟表

11.redo日志和undo日志
redo-存储引擎层面的,保证持久性,关键是write-ahead-log
undo-反向操作,保证原子性和一致性,同时保证MVCC

12.数据库三范式
列不可再分
消除部分主键依赖
消除传递依赖

13.表数据怎么找
8之前是frm+myd+myi
8之后是idb

14.myisam和Innodb区分
是否支持事务，是否支持行锁，是否支持聚簇索引，是否支持外键，是否支持共享表空间、是否保存行数（myisam）、是否支持全文索引（myisam）

15.memory引擎
只对frm文件持久化，数据存在内存中，使用哈希索引

16.什么是存储引擎
实际上就是MySQL怎么组织数据的存储，索引的建立，数据怎么查询修改等问题的一套实现方案

17.临时表
临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。
因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表

18.哈希索引比较
哈希索引不支持范围查询、排序操作
不支持联合索引的部分匹配，回表的次数也更多
哈希冲突的存在，还是要扫描表

19.最左前缀匹配原则

20.索引失效的情形
- 联合联合索引从最左边为起点开始连续匹配，遇到范围查询（<、>、between、like）会停 止匹配
- 

21.适合建索引的情形
where、group by、order by、字段有唯一性要求的
不适合建索引的情形
列使用频率低、无序列、经常更新的字段

22.聚集索引
物理顺序和索引顺序一致连续，这样查询速率就更高了，查到主键立刻就查到了完整的记录数据，代价是更新操作的代价变高

23.explain:seltype,table,type,possib_key,key,key_len
返回读取表的顺序、使用的索引情况、查询优化情况
select_type 查询类型（子查询和联合查询不为simple）
table 查询的表
type 执行查询的效率级别 system const  eq_ref ref range index all
possible_key  执行查询时可能会用到的索引
key 实际使用的索引
rows 扫描的行数

24.锁类型
全局锁 
表所 lock table 表名 read/write，冲突高，并发度低，不会出现死锁
页级锁 折中的加锁粒度，并发度和冲突概率都折中了
行锁 lock in share mode; for update，冲突低，并发度高

25.行锁的类别
记录锁 record lock 锁的是一条索引记录,没有索引时会添加隐藏的聚集索引
间隙锁 gap lock 锁住索引区间,可以防止幻读,不会锁住记录本身
临间锁next-key lock 左开右闭区间的锁

26.可重读情形下MySQL一定程度解决了幻读问题
不加锁策略：MVCC快照读
加锁策略：临键锁

27.MySQL主从复制的同步方式
同步、异步、半同步（slave返回一个就不阻塞）

28.用show profile查看SQL1执行细节
show profile 查询io、cpu等的开销情况

29.sql实际执行顺序：
1 客户端通过sql接口直接访问查询缓存，命中后直接将键值对查询结果返回给客户端
2 sql接口 -> 解析器生成解析树 -> 查询优化器生成执行计划 -> 判断权限后执行引擎进行查询

30.解决死锁的关键：保持不同线程一致的加锁顺序

31.解决死锁的办法
- 查出线程杀死
- 设置timeout超时关闭会话的策略

32.高并发的MySQL解决解决方案
分布式：分库分表、搭建集群
增加二级缓存

33.分库分表
单库单表导致db性能持续低下针对地提出的方案。主要的两个原因：存储量和连接数限制
垂直分库：按业务划分不同的表到不同的数据库中去
水平分库：和垂直分表对应。每个数据库有相同的表，不同库的相同表存放不同的id段
垂直分表：按id分为多表，因此此时要考虑自增情形下的主键冲突问题，uuid是字符串不合适，所以用雪花算法生成id
水平分表：按照字段的使用频率分为冷表和热表
分库分表的中间件有mycat、sharding jdbc等

34.分布式序列算法
目标:全局唯一、尽量有序
uuid不符合尽量有序
雪花算法：时间戳+节点id+序列号

35.MySQL的主从复制是增量复制，没有一开始的全量复制，空库同步一般要等待比较长的时间

36.索引的好处
加速查询,加速连接,加速分组或排序,保证某列唯一
索引的缺点：维护索引时间成本高，索引占用物理空间

37.不使用外键的原因
- 外键对分库分表要求更高
- 级联操作需要额外加锁



