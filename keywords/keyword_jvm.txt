1.JVM的性质：应用程序虚拟机，Java虚拟机执行字节码基于栈的指令体系架构（不同于基于寄存器的指令架构）

2.HotSpot VM是目前市面上高性能虚拟机的代表之一.采用解释器与即时编译器（将热点代码编译为机器代码）并存的架构.

3.JVM指令大部分没有操作数，大多是出栈入栈操作，而汇编指令经常使用操作数，因此C的执行效率比较高，实现相同的操作，最终的执行指令数更少，Java在本质上是基于栈指令牺牲执行效率来完成跨平台的特性。
因此为提高执行效率JVM会通过JNI(Java Native Interface)即时编译器机制大量调用C的本地方法。而安卓这种对性能要求严苛的OS采用的是定制的JVM，是基于寄存器的指令集架构。

4.热点代码探测技术和JIT Compiller
JVM会根据当前代码判断，当某部分代码的执行频率大时将其认定为热点代码，运行时将这些代码编译为本地系统的机器码进行优化，从而提高执行效率，完成这个过程的编译器就是JIT Compiller即时编译器

5.JVM对内存管理采用分区管理，不同内存区有其各自的职责功能所在，分区大致为运行时数据区和执行引擎、本地库接口，运行时数据区可分为线程隔离数据区和线程共享数据区，线程共享数据区包括方法区和堆，而线程隔离数据区包括虚拟机栈、本地方法栈和程序计数器

6.程序计数器
JVM多线程是通过时间片轮转来实现的，线程在执行的过程中可能因为时间片耗尽而挂起，PC Register作为线程隔离的内存区域，只在程序执行时有值，负责记录程序正在执行的字节码的地址

7.虚拟机栈和系统方法栈（变量表、操作数栈、动态链接、返回地址）
VM Stack也是线程隔离的，方法被调用时JVM会同步地建立一个栈帧
栈帧包括局部变量表、操作数栈、动态链接和方法出口
动态链接指向运行时常量池（在栈帧中，指向当前方法所在类）的所调用方法的符号引用，在类加载阶段将其转换为直接引用（静态解析）
返回地址可以是方法返回指令，也可以是异常退出

本地方法栈和虚拟机栈类似

8.方法区
方法区包括类信息表和运行时常量池，类信息包括类的版本、字段、方法信息、类加载器等

9.堆
存放对象和数组，是JVM最大的内存区域

10.栈溢出和内存溢出
可以在run config中去指定运行参数， -XmsMIN_VALUE，-XmxMAX_VALUE

11.堆外内存
类似于C语言malloc的操作，反射获取Unsafe类中的单例对象，使用allocateMemory就能返回申请内存空间的地址

12.对象存活的两种算法思路
引用计数法，每个对象都会统计引用数，引用数为0则回收，但是存在多层引用删除上层后下层还存在的问题，且对象循环引用也没能判死
可达性分析（主流），根据是否可达GC root来判定是否进行回收
判定为gcroot的条件：
静态对象、栈空间的变量表对象、加锁对象、常量

12.
在垃圾回收时还允许进行一次判定（Object类的finalize方法），判定是否回收该对象，如果重新可达GC root,则不被回收，第二次回收时将不再进行finalize判断直接回收。finalize一般并不会重新让对象可达根节点，而是在对象回收时进行一些同意的资源释放操作。
可达性分析和finalize机制共同构成了对象存活判定算法

13.分代收集机制
鉴于有些对象长期不被回收，JVM将减少对其进行存活判定的频率。
基于此思路将堆内存划分为新生代、老年代和永久代，顾名思义新生代的存活判定频率最高，永久代实际上就是方法区的实现。

14.分代内存回收机制在具体的JVM上有所不同，以HotSpot为例
新生代包括三块空间，Eden、From、To三块大小比例默认为8:1:1，from区和to区是survivor区

15.分代收集机制的收集-老化过程
新创建的对象都将放入新生代edon区，新生代的GC会对所有新生代扫描，回收判定不存活的对象
未被回收的对象将移入from区
to区的对象进行扫描和年龄判定，扫描后标记失活对象，剩余的对象年龄进行加一操作，大于15就移入老年代，小于15的移入from区，然后对to区进行回收
from和to区进行一次交换，最终保证to区最终为空

16.GC 分级
Minor GC 次要垃圾回收，当Edon区容量已满时，进行新生代的垃圾回收
Major GC 主要垃圾回收，主要进行老年代垃圾回收
Full GC 完全垃圾回收，对整个Java堆内存和方法区进行回收
	触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间
	触发条件2：Minor GC后存活的对象超过了老年代剩余空间
	触发条件3：永久代内存不足（JDK8之前）
	触发条件4：手动调用System.gc()方法

17.GC日志
在run config 中添加 -XX:+PrintCGDetails

18.空间分配担保
如果minor GC后新生代有大量的存活对象,survivor中明显放不下,则由老年代来担保存放，存放前要根据此前minor GC的老化数量进行预期判断，过大则进行一次Full GC，再存放不下只能OOM

19.垃圾回收算法
标记-清除算法	标记存活/失活对象后收集即可，会造成大量内存间隙,会更容易触发full GC
标记-复制算法	将目标空间分区为两分，每次只使用其中一分，收集时将对象标记后移到另一分，对失活对象回收即可
标记=整理算法	思路是将标记/未标记对象进行连续排序，连续回收掉标记对象
新生代使用标记复制算法，老年代使用标记整理算法，因为新生代回收比例大，老年代则比较小
标记-清除方式进行回收效率较高，当目标空间的大小比较小不怎么凌乱时可以采用，因此经常是多种算法混合使用

20.常见GC的实现
serial 单线程
Parallel Scavenge/Parallel Old收集器，会自动根据吞吐量决定垃圾回收的时间进行自适应，是多线程GC
CMS收集器，第一款真正意义上的并发(与用户线程并发)收集器，并发清除时使用的是标记清除算法，产生大量的内存碎片
G1收集器，jdk9全面替代PS/PO方案，将所有的堆内存划分为2k个独立的Region块，块大小按实际大小决定，为2的幂，块的角色可以根据需要自由决定。
无论是CMS收集还是G1收集中初始标记和最终标记都要暂停用户线程

21.元空间
永久代在jdk8被彻底摒弃，即原来的方法区的实现，方法区实际上是堆内存划分出来的一片空间，用于存放类信息和常量池。
jdk7将字符串常量池从方法区常量池中移出来放至堆内存中
jdk8开始，方法区采用元空间实现，采用本地直接内存，可以根据方法区实际大小进行伸缩

22.引用类型
强引用			一般的引用就是强引用，按可达性算法判定是否回收
软引用SoftReference	内存不够时进行回收
弱引用WeakReference	gc必定回收
虚引用			随时可能被回收，必须接受queue
软引用、弱引用、虚引用创建的时候可以指定传入ReferenceQueue,回收后queue中会加入引用指向的元素

23.weakhashmap
如果entry的value没有实际的对象，则会自动抛弃此entry

24.ASM字节码框架，可以直接修改或生成字节码文件

25.类加载的5个过程：加载-验证-准备-解析-初始化，完整的生命周期则还有使用和卸载

26.注意常量的使用不会触发当前类的加载，因为虚拟机会进行编译优化，直接从常量池拿值进行替换。

25.类的初始化顺序
父类静态变量显式初始化->父类静态代码块初始化->静态变量显式初始化->静态代码块初始化
->父类成员变量显式初始化->父类代码块初始化->父类构造器初始化
->成员变量显式初始化->代码块初始化->构造器初始化

26.动态代理的实现与类的加载
jdk代理使用专门的类来生成代理类的二进制流
cglib是在已有的class类对象上进行修改的
类的加载步骤第一步加载可以分为几步：获取二进制流，在方法区建立运行时数据结构，在内存中生成class对象作为访问方法区类信息的入口

27.类加载器
同一个类文件不同的类加载器加载生成的类对象，实际上不是同一个类对象

28.双亲委派机制
Apploader、ExtLoader、BoostrapLoader逐次向上查找是否加载过、是否可以加载，已加载则不再加载，允许加载则采用父类加载器进行加载，直至appclassloader加载失败抛出classnotfound异常

29.判定为GCRoot的对象？
本地方法栈或虚拟机栈变量表中引的对象，常量对象，静态变量引用的对象，加锁的对象

30.栈溢出、内存泄漏和内存溢出
栈溢出：一般是递归死循环，不断建立新的栈帧
内存溢出：对象、线程等资源分配太多导致溢超出内存限制
内存泄漏：对象不能被及时回收的状态，如静态对象











